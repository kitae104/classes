# [강의 요약] 11장. JDK 기본 클래스

## 🎯 강의 목표
* [cite_start]**`java.lang` 패키지의 특성 이해**: 프로그래밍 시 별도의 `import` 없이 자동으로 추가되는 기본 패키지의 역할을 이해한다. [cite: 10, 11]
* [cite_start]**최상위 클래스 `Object` 마스터**: 모든 자바 클래스의 조상인 `Object` 클래스의 주요 메서드를 학습하고, 필요에 따라 이를 재정의(Override)하는 방법을 습득한다. [cite: 49, 52, 53]
* [cite_start]**효율적인 문자열 처리**: `String` 클래스의 불변성(Immutable)을 이해하고, 상황에 맞는 `StringBuilder`와 `StringBuffer` 활용법을 배운다. [cite: 306, 322, 325]
* [cite_start]**현대적 자바 문법 활용**: 상수 집합인 `enum`, 데이터 중심 클래스인 `record`, 그리고 실행 중 클래스 정보를 분석하는 `Reflection`의 기초를 다진다. [cite: 365, 441, 496]

---

## 📝 주요 강의 내용

### 1. Object 클래스: 자바의 최상위 클래스
* [cite_start]**기본 특징**: 모든 클래스는 `Object` 클래스로부터 상속을 받으며, 컴파일러가 자동으로 `extends Object`를 추가한다. [cite: 49, 51, 54]
* **핵심 메서드**:
    * **`toString()`**: 객체를 문자열로 표현한다. [cite_start]기본값은 '클래스명@해시코드'이나, 멤버 변수 값을 확인하도록 재정의하여 사용한다. [cite: 66, 69, 72]
    * **`equals()`**: 두 인스턴스의 주소 값을 비교한다. [cite_start]논리적으로 동일한 객체임을 정의하기 위해 학번이나 ID 등을 기준으로 재정의한다. [cite: 66, 110, 112]
    * **`hashCode()`**: JVM이 저장한 객체의 주소 값을 10진수로 반환한다. [cite_start]논리적으로 같은 객체라면 동일한 해시코드를 가져야 하므로 `equals()`와 함께 재정의한다. [cite: 66, 174, 178]
    * **`clone()`**: 객체의 원본을 복제한다. [cite_start]이를 위해 해당 클래스는 `Cloneable` 인터페이스를 구현해야 한다. [cite: 222, 227]

### 2. 문자열 관리 클래스
* **`String`**: 한번 생성되면 값이 변하지 않는 **불변(Immutable)** 객체이다. [cite_start]문자열을 연결하면 매번 새로운 인스턴스가 생성되어 메모리 낭비가 발생할 수 있다. [cite: 306, 307, 308]
* [cite_start]**`StringBuilder` & `StringBuffer`**: 내부적으로 가변적인 `char[]` 배열을 사용하여 기존 배열을 직접 변경하므로 메모리 효율이 좋다. [cite: 323, 324]
    * [cite_start]`StringBuilder`: 단일 스레드 환경에서 권장된다. [cite: 326]
    * [cite_start]`StringBuffer`: 멀티 스레드 환경에서 동기화(Synchronization)를 보장한다. [cite: 325]

### 3. enum 및 record 클래스
* [cite_start]**`enum` (열거형)**: 관련 있는 상수를 클래스처럼 관리하며, 각 상수에 특정 값(숫자, 문자열 등)을 부여하여 객체처럼 활용할 수 있다. [cite: 365, 372, 373]
* [cite_start]**`record`**: 불변 데이터 객체를 정의하기 위한 특수 클래스로, 필드가 `private final`로 선언되며 `getter`, `equals`, `toString` 등을 자동으로 생성한다. [cite: 441, 442, 445]

### 4. Class 클래스와 리플렉션
* [cite_start]**개념**: 실행 중인 자바 프로그램에서 클래스의 생성자, 필드, 메서드 정보를 동적으로 가져오는 방식이다. [cite: 496]
* [cite_start]**동적 로딩**: `Class.forName("클래스명")`을 사용하면 컴파일 시점이 아닌 실행 시점에 클래스를 찾아 바인딩할 수 있다. [cite: 557, 558]

---

## 🚀 수업 후 할 수 있는 일
* [cite_start]**사용자 정의 객체 비교**: `Book`이나 `Student` 클래스를 설계할 때, 고유 번호가 같다면 주소가 달라도 동일 객체로 인식하도록 `equals()`와 `hashCode()`를 직접 구현해 볼 수 있다. [cite: 88, 134, 194]
* [cite_start]**대량의 문자열 연산 최적화**: 반복문 안에서 수백 번 이상 문자열을 더해야 할 때, `String` 대신 `StringBuilder`를 활용하여 프로그램의 성능을 개선할 수 있다. [cite: 323, 348]
* [cite_start]**유연한 프로그램 설계**: `Class.forName()`과 리플렉션을 응용하여, 프로그램 실행 중에 사용자의 입력에 따라 서로 다른 클래스를 로드하고 메서드를 호출하는 동적 기능을 구현해 볼 수 있다. [cite: 500, 559]

## 수업 관련 마인드 맵

![img.png](img.png)